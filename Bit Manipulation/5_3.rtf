{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 Menlo-Bold;}
{\colortbl;\red255\green255\blue255;\red63\green127\blue95;\red127\green0\blue85;\red42\green0\blue255;
\red0\green80\blue50;\red0\green0\blue192;\red100\green40\blue128;}
\margl1440\margr1440\vieww28300\viewh14680\viewkind0
\deftab720
\pard\pardeftab720

\f0\fs24 \cf2 //Algorithm :   flipBitArray : Store the length of 0's at the even indices of the array and\cf0 \
\cf2 //              length of 1's at odd indices. Since right shift operator won't work well for\cf0 \
\cf2 //              negative numbers, we need to have the opposite mask and approach for them.\cf0 \
\cf2 //              Count array will contain count of 0's at vec.begin() position for \cf2 \ul \ulc2 num\cf2 \ulnone >0 and \cf0 \
\cf2 //              count of 1's for \cf2 \ul \ulc2 num\cf2 \ulnone <0.\cf0 \
\cf2 //              Time Complexity : O(b) ; Space complexity : O(b) where b is the number of bits\cf0 \
\cf2 //              
\f1\b \ul TODO:
\f0\b0 \ulnone    flipBit : Generate a mask such that the value of bit can be found by anding it with a \cf0 \
\cf2 //				1 at that location. If it is 1, increment current length. If it is 0 and next bit is 0, \cf0 \
\cf2 //				set \cf2 \ul \ulc2 prev\cf2 \ulnone  length to 0. If next bit is 1, set \cf2 \ul \ulc2 prev\cf2 \ulnone  \cf2 \ul \ulc2 len\cf2 \ulnone  to current length and reset \cf2 \ul \ulc2 curr\cf2 \ulnone  \cf2 \ul \ulc2 len\cf2 \ulnone .\cf0 \
\cf2 //				Shift the mask to check the next bit\cf0 \
\cf2 //              Time Complexity : O(b); Space Complexity : O(1)\cf0 \
\
\pard\pardeftab720

\f1\b \cf3 using
\f0\b0 \cf0  
\f1\b \cf3 namespace
\f0\b0 \cf0  std;\

\f1\b \cf3 #include
\f0\b0 \cf0  \cf4 <iostream>\cf0 \

\f1\b \cf3 #include
\f0\b0 \cf0  \cf4 <bitset>\cf0 \

\f1\b \cf3 #include
\f0\b0 \cf0  \cf4 <vector>\cf0 \

\f1\b \cf3 #include
\f0\b0 \cf0  \cf4 <math.h>\cf0 \

\f1\b \cf3 #include
\f0\b0 \cf0  \cf4 <algorithm>\cf0 \
\

\f1\b \cf3 class
\f0\b0 \cf0  \cf5 myClass\cf0  \{\
    
\f1\b \cf3 public
\f0\b0 \cf0  :\
        
\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b createCountArray
\f0\b0 (
\f1\b \cf3 int
\f0\b0 \cf0  num);\
        
\f1\b \cf3 int
\f0\b0 \cf0  
\f1\b flipBitArray
\f0\b0 (
\f1\b \cf3 int
\f0\b0 \cf0  num);\
        
\f1\b \cf3 int
\f0\b0 \cf0  
\f1\b flipBit
\f0\b0 (
\f1\b \cf3 int
\f0\b0 \cf0  num);\
    
\f1\b \cf3 private
\f0\b0 \cf0  : \
        \cf5 vector\cf0 <
\f1\b \cf3 int
\f0\b0 \cf0 > \cf6 vec\cf0 ;\
\};\
\

\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b myClass :: createCountArray
\f0\b0 (
\f1\b \cf3 int
\f0\b0 \cf0  num) \{\
    
\f1\b \cf3 int
\f0\b0 \cf0  count = 0;\
    
\f1\b \cf3 int
\f0\b0 \cf0  val = num;\
    
\f1\b \cf3 int
\f0\b0 \cf0  check;\
    
\f1\b \cf3 bool
\f0\b0 \cf0  pushDone = 
\f1\b \cf3 false
\f0\b0 \cf0 ;\
    
\f1\b \cf3 int
\f0\b0 \cf0  totalCount = 0;\
    
\f1\b \cf3 bool
\f0\b0 \cf0  reverse = (num<0) ? 
\f1\b \cf3 true
\f0\b0 \cf0  : 
\f1\b \cf3 false
\f0\b0 \cf0 ;\
    
\f1\b \cf3 int
\f0\b0 \cf0  mask = reverse ? 
\f1\b \cf7 pow
\f0\b0 \cf0 (2,31) : 1;\
    
\f1\b \cf3 int
\f0\b0 \cf0  findZero = reverse ? mask : 0;\
\
    
\f1\b \cf3 while
\f0\b0 \cf0  ((val != 0) || !pushDone) \{\
        check = val&mask;\
        \cf2 //\cf2 \ul \ulc2 cout\cf2 \ulnone  << "\cf2 \ul \ulc2 num\cf2 \ulnone  : " << \cf2 \ul \ulc2 bitset\cf2 \ulnone <32>(\cf2 \ul \ulc2 val\cf2 \ulnone ) << " for findZero : " << findZero << " and \cf2 \ul \ulc2 val\cf2 \ulnone &mask : " << \cf2 \ul \ulc2 bitset\cf2 \ulnone <32>(check) << " with count " << count << \cf2 \ul \ulc2 endl\cf2 \ulnone ;\cf0 \
        
\f1\b \cf3 if
\f0\b0 \cf0  (check == findZero) \{\
            count++;\
            val = reverse ? val << 1 : val >> 1; \cf2 //For negative numbers, right shift is undefined\cf0 \
            pushDone = 
\f1\b \cf3 false
\f0\b0 \cf0 ;\
            totalCount++;\
        \} 
\f1\b \cf3 else
\f0\b0 \cf0  \{\
            \cf6 vec\cf0 .push_back(count);\
            
\f1\b \cf3 if
\f0\b0 \cf0  (findZero == 0)\
                findZero = reverse ? mask : 1;\
            
\f1\b \cf3 else
\f0\b0 \cf0 \
                findZero = 0;\
            count = 0;\
            pushDone = 
\f1\b \cf3 true
\f0\b0 \cf0 ;\
        \}\
    \}\
    \cf6 vec\cf0 .push_back(32-totalCount);\
    
\f1\b \cf3 if
\f0\b0 \cf0  (reverse) \{\
        cout << \cf4 "Reverse Count array for integer : "\cf0  << \cf5 bitset\cf0 <32>(num) << \cf4 " is : "\cf0  << endl;\
        
\f1\b \cf3 for
\f0\b0 \cf0  (
\f1\b \cf3 auto
\f0\b0 \cf0  itr = \cf6 vec\cf0 .begin(); itr!= \cf6 vec\cf0 .end(); ++itr )\
            cout << *itr << \cf4 " "\cf0 ;\
        cout << endl;\
        \cf5 vector\cf0 <
\f1\b \cf3 int
\f0\b0 \cf0 > rev_vec;\
        
\f1\b \cf3 for
\f0\b0 \cf0  (
\f1\b \cf3 auto
\f0\b0 \cf0  itr=\cf6 vec\cf0 .rbegin(); itr!=\cf6 vec\cf0 .rend(); ++itr)\
            rev_vec.push_back(*itr); \cf2 //Reverse the vector\cf0 \
        \cf6 vec\cf0  = rev_vec;\
        \cf6 vec\cf0 .push_back(0); \cf2 //As negative numbers have 1 in MSB\cf0 \
    \}\
    cout << \cf4 "Count array for integer : "\cf0  << \cf5 bitset\cf0 <32>(num) << \cf4 " is : "\cf0  << endl;\
    
\f1\b \cf3 for
\f0\b0 \cf0  (
\f1\b \cf3 auto
\f0\b0 \cf0  itr = \cf6 vec\cf0 .begin(); itr!= \cf6 vec\cf0 .end(); ++itr )\
        cout << *itr << \cf4 " "\cf0 ;\
    cout << endl;\
\}\
\

\f1\b \cf3 int
\f0\b0 \cf0  
\f1\b myClass :: flipBitArray
\f0\b0 (
\f1\b \cf3 int
\f0\b0 \cf0  num) \{\
    
\f1\b \cf3 if
\f0\b0 \cf0  (num == -1) \cf2 //All 1's\cf0 \
        
\f1\b \cf3 return
\f0\b0 \cf0  32;\
    
\f1\b \cf3 else
\f0\b0 \cf0  
\f1\b \cf3 if
\f0\b0 \cf0  (num == 0)\
        
\f1\b \cf3 return
\f0\b0 \cf0  1;\
    \
    createCountArray(num);\
\
    
\f1\b \cf3 int
\f0\b0 \cf0  prev_len, next_len, max_len, curr_len;\
    max_len = 1; \cf2 //As we can always flip \cf2 \ul \ulc2 atleast\cf2 \ulnone  one 1.\cf0 \
    
\f1\b \cf3 int
\f0\b0 \cf0  first, last;\
    \cf2 //first stores 0 length and then +2 will have 0 length again\cf0 \
    
\f1\b \cf3 for
\f0\b0 \cf0  (
\f1\b \cf3 auto
\f0\b0 \cf0  itr = \cf6 vec\cf0 .begin(); itr != \cf6 vec\cf0 .end()-1; itr = itr+2) \{\
        prev_len = (itr == \cf6 vec\cf0 .begin()) ? 0 : *(itr-1);\
        next_len = (itr == \cf6 vec\cf0 .end()-1) ? 0 : *(itr+1);\
        
\f1\b \cf3 if
\f0\b0 \cf0  (*itr == 0)  \
            curr_len = max(prev_len, next_len);\
        
\f1\b \cf3 else
\f0\b0 \cf0  
\f1\b \cf3 if
\f0\b0 \cf0  (*itr > 1) \cf2 //\cf2 \ul \ulc2 Cant\cf2 \ulnone  merge but we can flip adjacent 0 to 1 to create max length\cf0 \
            curr_len = max(prev_len, next_len) + 1;\
        
\f1\b \cf3 else
\f0\b0 \cf0  
\f1\b \cf3 if
\f0\b0 \cf0  (*itr == 1) \cf2 //Can merge\cf0 \
            curr_len = prev_len + next_len + 1;\
        max_len = max(max_len, curr_len);\
        cout << \cf4 "Current length for "\cf0  << *itr << \cf4 " is "\cf0  << curr_len << endl;\
\
    \}\
    
\f1\b \cf3 return
\f0\b0 \cf0  max_len;\
\}\
\

\f1\b \cf3 int
\f0\b0 \cf0  
\f1\b myClass :: flipBit
\f0\b0 (
\f1\b \cf3 int
\f0\b0 \cf0  num) \{\
    
\f1\b \cf3 if
\f0\b0 \cf0  (num == -1) \cf2 //All 1's\cf0 \
        
\f1\b \cf3 return
\f0\b0 \cf0  32;\
    
\f1\b \cf3 else
\f0\b0 \cf0  
\f1\b \cf3 if
\f0\b0 \cf0  (num == 0)\
        
\f1\b \cf3 return
\f0\b0 \cf0  1;\
    \
    
\f1\b \cf3 int
\f0\b0 \cf0  val = num;\
    
\f1\b \cf3 int
\f0\b0 \cf0  curr_len = 0;\
    
\f1\b \cf3 int
\f0\b0 \cf0  prev_len = 0;\
    
\f1\b \cf3 int
\f0\b0 \cf0  mask = (num<0) ? 
\f1\b \cf7 pow
\f0\b0 \cf0 (2,31) : 1;\
    
\f1\b \cf3 int
\f0\b0 \cf0  mask2 = (num<0) ? (mask>>1) : (mask<<1) ;\
    
\f1\b \cf3 int
\f0\b0 \cf0  max_len = 1;\
    
\f1\b \cf3 while
\f0\b0 \cf0 (val != 0) \{\
        
\f1\b \cf3 if
\f0\b0 \cf0  ((val&mask) == mask) \
            curr_len++;\
        
\f1\b \cf3 else
\f0\b0 \cf0  
\f1\b \cf3 if
\f0\b0 \cf0  ((val&mask) == 0) \{\
            prev_len = ((val&mask2) == 0) ? 0 : curr_len;\
            curr_len = 0;\
        \}\
        max_len = max(max_len, prev_len+curr_len+1);\
        cout << \cf4 "For \cf4 \ul \ulc4 val\cf4 \ulnone  "\cf0  << \cf5 bitset\cf0 <32>(val) << \cf4 " curr_len "\cf0  << curr_len << \cf4 " prev_len "\cf0  << prev_len << \cf4 " max_len "\cf0  << max_len << endl;\
        val = (num<0) ? val << 1 : val >> 1;\
    \}\
    \
    
\f1\b \cf3 return
\f0\b0 \cf0  max_len;\
\}\
\

\f1\b \cf3 int
\f0\b0 \cf0  
\f1\b main
\f0\b0 () \{\
    \
    \cf5 myClass\cf0  obj;\
    
\f1\b \cf3 int
\f0\b0 \cf0  x = -49;\
    cout << \cf4 "Array : Max length of 1's by \cf4 \ul \ulc4 flipping\cf4 \ulnone  just 1 bit from 0 to 1 for \cf4 \ul \ulc4 num\cf4 \ulnone  "\cf0  << \cf5 bitset\cf0 <32>(x) << \cf4 " is "\cf0  << obj.flipBitArray(x) << endl;\
    cout << \cf4 "Max length of 1's by \cf4 \ul \ulc4 flipping\cf4 \ulnone  just 1 bit from 0 to 1 for \cf4 \ul \ulc4 num\cf4 \ulnone  "\cf0  << \cf5 bitset\cf0 <32>(x) << \cf4 " is "\cf0  << obj.flipBit(x) << endl;\
\
    
\f1\b \cf3 return
\f0\b0 \cf0  0;\
\}\
}