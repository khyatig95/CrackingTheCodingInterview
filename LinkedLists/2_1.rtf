{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 Menlo-Bold;}
{\colortbl;\red255\green255\blue255;\red63\green127\blue95;\red127\green0\blue85;\red42\green0\blue255;
\red100\green70\blue50;\red0\green80\blue50;\red0\green0\blue192;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720

\f0\fs24 \cf2 //Assumption :  Linked list is made of integers\cf0 \
\cf2 //Algorithm  :  isDup : Iterates through the list for each element to check for duplicate\cf0 \
\cf2 //              Time Complexity : O(N^2) ; Space Complexity : O(1)\cf0 \
\cf2 //              isDupHash : Stores element from list to hash one at a time. If element\cf0 \
\cf2 //              already exists, delete that element from list\cf0 \
\cf2 //              Time Complexity : O(N)  ; Space Complexity : O(N)\cf0 \
\
\pard\pardeftab720

\f1\b \cf3 #include
\f0\b0 \cf0  \cf4 <iostream>\cf0  \

\f1\b \cf3 #include
\f0\b0 \cf0  \cf4 <unordered_set>\cf0 \

\f1\b \cf3 #include
\f0\b0 \cf0  \cf4 "LinkedList.h"\cf0 \
\

\f1\b \cf3 using
\f0\b0 \cf0  
\f1\b \cf3 namespace
\f0\b0 \cf0  std; \
\

\f1\b \cf3 template
\f0\b0 \cf0  <
\f1\b \cf3 typename
\f0\b0 \cf0  
\f1\b \cf5 T
\f0\b0 \cf0 > \

\f1\b \cf3 class
\f0\b0 \cf0  \cf6 myClass\cf0  : 
\f1\b \cf3 public
\f0\b0 \cf0  \ul LinkedList<
\f1\b \cf5 \ulc5 T
\f0\b0 \cf0 \ulc0 >\ulnone  \{\
    
\f1\b \cf3 public
\f0\b0 \cf0  :\
        
\f1\b \cf3 bool
\f0\b0 \cf0  
\f1\b isDup
\f0\b0 ();\
        
\f1\b \cf3 bool
\f0\b0 \cf0  
\f1\b isDupHash
\f0\b0 ();\
    
\f1\b \cf3 private
\f0\b0 \cf0  : \
        
\f1\b \cf3 bool
\f0\b0 \cf0  \cf7 has_duplicate\cf0 ;\
\};\
\

\f1\b \cf3 template
\f0\b0 \cf0  <
\f1\b \cf3 typename
\f0\b0 \cf0  
\f1\b \cf5 T
\f0\b0 \cf0 > \

\f1\b \cf3 bool
\f0\b0 \cf0  
\f1\b myClass<T> :: isDup
\f0\b0 () \{\
    \ul Node<
\f1\b \cf5 \ulc5 T
\f0\b0 \cf0 \ulc0 >\ulnone * itr1 = 
\f1\b \cf3 this
\f0\b0 \cf0 ->\ul head\ulnone ;\
    \ul Node<
\f1\b \cf5 \ulc5 T
\f0\b0 \cf0 \ulc0 >\ulnone * itr2;\
    \ul Node<
\f1\b \cf5 \ulc5 T
\f0\b0 \cf0 \ulc0 >\ulnone * ptr;\
    \cf7 has_duplicate\cf0  = 
\f1\b \cf3 false
\f0\b0 \cf0 ;\
    
\f1\b \cf3 bool
\f0\b0 \cf0  skip = 
\f1\b \cf3 false
\f0\b0 \cf0 ;\
    
\f1\b \cf3 if
\f0\b0 \cf0  (
\f1\b \cf3 this
\f0\b0 \cf0 ->\ul head\ulnone  == NULL) \{\
        cout << \cf4 "Empty Linked List"\cf0  << endl;\
        
\f1\b \cf3 return
\f0\b0 \cf0  \cf7 has_duplicate\cf0 ;\
    \}\
    \cf2 //itr1 iterates through head to tail-1\cf0 \
    \cf2 //itr2 iterates through itr1+1 to tail\cf0 \
    \cf2 //We delete itr1 if found. Since it doesn't go to tail,\cf0 \
    \cf2 //We can use deleteNode from 2_3 as it is O(1) only.\cf0 \
    
\f1\b \cf3 while
\f0\b0 \cf0  (itr1 != NULL) \{\
        itr2 = itr1->\ul next\ulnone ;\
        
\f1\b \cf3 while
\f0\b0 \cf0 (itr2 != NULL) \{\
            cout << \cf4 "Comparing "\cf0  << itr1->\ul data\ulnone  << \cf4 " at "\cf0  << itr1 << \cf4 " with "\cf0  << itr2->\ul data\ulnone  << \cf4 " at "\cf0  << itr2 << \ul endl\ulnone ;\
            
\f1\b \cf3 if
\f0\b0 \cf0  (itr1->\ul data\ulnone  == itr2->\ul data\ulnone ) \{ \cf2 //Duplicates\cf0 \
                \cf7 has_duplicate\cf0  = 
\f1\b \cf3 true
\f0\b0 \cf0 ;\
                cout << \cf4 "Found duplicate and deleting node "\cf0  << itr1 << endl;\
                ptr = itr1;\
                itr1 = itr1->\ul next\ulnone ;\
                
\f1\b \cf3 this
\f0\b0 \cf0 ->\ul deleteNode\ulnone (ptr);\
                skip = 
\f1\b \cf3 true
\f0\b0 \cf0 ; \cf2 //By deleting the node at itr1, we are already at itr1->next\cf0 \
                
\f1\b \cf3 break
\f0\b0 \cf0 ;\
            \} 
\f1\b \cf3 else
\f0\b0 \cf0 \
                skip = 
\f1\b \cf3 false
\f0\b0 \cf0 ;\
            itr2 = itr2->\ul next\ulnone ;\
        \}\
        
\f1\b \cf3 if
\f0\b0 \cf0  (skip == 
\f1\b \cf3 false
\f0\b0 \cf0 )\
            itr1 = itr1->\ul next\ulnone ;\
    \}\
    
\f1\b \cf3 return
\f0\b0 \cf0  \cf7 has_duplicate\cf0 ;\
\}\
\

\f1\b \cf3 template
\f0\b0 \cf0  <
\f1\b \cf3 typename
\f0\b0 \cf0  
\f1\b \cf5 T
\f0\b0 \cf0 > \

\f1\b \cf3 bool
\f0\b0 \cf0  
\f1\b myClass<T> :: isDupHash
\f0\b0 () \{\
    \ul Node<
\f1\b \cf5 \ulc5 T
\f0\b0 \cf0 \ulc0 >\ulnone * n = 
\f1\b \cf3 this
\f0\b0 \cf0 ->\ul head\ulnone ;\
    \ul Node<
\f1\b \cf5 \ulc5 T
\f0\b0 \cf0 \ulc0 >\ulnone * temp;\
    \ul unordered_set<
\f1\b \cf3 \ulc3 int
\f0\b0 \cf0 \ulc0 >\ulnone  uset;\
    \cf7 has_duplicate\cf0  = 
\f1\b \cf3 false
\f0\b0 \cf0 ;\
    
\f1\b \cf3 if
\f0\b0 \cf0  (
\f1\b \cf3 this
\f0\b0 \cf0 ->\ul head\ulnone  == NULL) \{\
        cout << \cf4 "Empty Linked List"\cf0  << endl;\
        
\f1\b \cf3 return
\f0\b0 \cf0  \cf7 has_duplicate\cf0 ;\
    \}\
    cout << \cf4 "Added "\cf0  << 
\f1\b \cf3 this
\f0\b0 \cf0 ->\ul head\ulnone ->\cf7 data\cf0  << \cf4 " to the uset"\cf0  << endl;\
    uset.\ul insert\ulnone (
\f1\b \cf3 this
\f0\b0 \cf0 ->\ul head\ulnone ->\cf7 data\cf0 ); \cf2 //The first element will be the first one\cf0 \
    
\f1\b \cf3 while
\f0\b0 \cf0 (n->\ul next\ulnone  != NULL) \{\
        cout << \cf4 "Process data "\cf0  << n->\ul next\ulnone ->\ul data\ulnone  << \cf4 " at node "\cf0  << n->\ul next\ulnone  << \ul endl\ulnone ;\
        
\f1\b \cf3 if
\f0\b0 \cf0  (uset.\ul find\ulnone (n->\ul next\ulnone ->\ul data\ulnone ) != uset.\ul end\ulnone ()) \{ \cf2 //Duplicate\cf0 \
            \cf7 has_duplicate\cf0  = 
\f1\b \cf3 true
\f0\b0 \cf0 ;\
            temp = n->\ul next\ulnone ;\
            n->\ul next\ulnone  = n->\ul next\ulnone ->\ul next\ulnone ;\
            cout << \cf4 "Delete Node "\cf0  << temp << \cf4 " with val "\cf0  << temp->\ul data\ulnone  << \ul endl\ulnone ;\
            
\f1\b \cf3 this
\f0\b0 \cf0 ->\ul deleteNode\ulnone (temp);\
        \} 
\f1\b \cf3 else
\f0\b0 \cf0  \{\
            uset.\ul insert\ulnone (n->\ul next\ulnone ->\ul data\ulnone );\
            cout << \cf4 "Added "\cf0  << n->\ul next\ulnone ->\ul data\ulnone  << \cf4 " to the uset"\cf0  << \ul endl\ulnone ;\
            n = n->\ul next\ulnone ;\
        \}\
    \}\
    
\f1\b \cf3 return
\f0\b0 \cf0  \cf7 has_duplicate\cf0 ;\
\}\
\
\

\f1\b \cf3 int
\f0\b0 \cf0  
\f1\b main
\f0\b0 () \{\
    \cf6 myClass\cf0 <
\f1\b \cf3 int
\f0\b0 \cf0 > lis;\
    lis.\ul insertNode\ulnone (70);\
    lis.\ul insertNode\ulnone (60);\
    lis.\ul insertNode\ulnone (100);\
    lis.\ul insertNode\ulnone (23);\
    lis.\ul insertNode\ulnone (60);\
    lis.\ul insertNode\ulnone (70); \
    lis.\ul insertNode\ulnone (70);\
    lis.\ul printLinkedList\ulnone ();\
    
\f1\b \cf3 if
\f0\b0 \cf0  (lis.isDupHash()) \
        cout << \cf4 "Linked List has duplicates"\cf0  << endl;\
    
\f1\b \cf3 else
\f0\b0 \cf0  \
        cout << \cf4 "Linked List has NO duplicates"\cf0  << endl;\
    lis.\ul printLinkedList\ulnone ();\
    
\f1\b \cf3 return
\f0\b0 \cf0  0;\
\}\
}