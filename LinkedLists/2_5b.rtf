{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 Menlo-Bold;}
{\colortbl;\red255\green255\blue255;\red63\green127\blue95;\red127\green0\blue85;\red42\green0\blue255;
\red0\green80\blue50;\red0\green0\blue192;}
\margl1440\margr1440\vieww28300\viewh14680\viewkind0
\deftab720
\pard\pardeftab720

\f0\fs24 \cf2 //Algorithm  :  doSumReverse : Pad zeroes if length not equal. Add partSum and recur return the carry.\cf0 \
\cf2 //              Add elements at head for the result list\cf0 \
\cf2 //              Tail has 1's place, tail->\cf2 \ul \ulc2 prev\cf2 \ulnone  has 10's place ...\cf0 \
\cf2 //              Time Complexity : O(N) where N is the longer list length; Space Complexity : O(1)\cf0 \
\pard\pardeftab720

\f1\b \cf3 using
\f0\b0 \cf0  
\f1\b \cf3 namespace
\f0\b0 \cf0  std;\

\f1\b \cf3 #include
\f0\b0 \cf0  \cf4 <iostream>\cf0 \
\pard\pardeftab720

\f1\b \cf3 \ul \ulc3 #include
\f0\b0 \cf0 \ulc0  \cf4 \ulc4 "LinkedList.h"\cf0 \ulnone \
\
\pard\pardeftab720

\f1\b \cf3 class
\f0\b0 \cf0  \cf5 myClass\cf0  \{\
    
\f1\b \cf3 public
\f0\b0 \cf0  :\
            
\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b padZeroes
\f0\b0 ();\
            
\f1\b \cf3 int
\f0\b0 \cf0  
\f1\b doSumReverse
\f0\b0 (\ul Node<
\f1\b \cf3 \ulc3 int
\f0\b0 \cf0 \ulc0 >\ulnone * n1, \ul Node<
\f1\b \cf3 \ulc3 int
\f0\b0 \cf0 \ulc0 >\ulnone * n2);\
            \ul LinkedList<
\f1\b \cf3 \ulc3 int
\f0\b0 \cf0 \ulc0 >\ulnone  \cf6 lis1\cf0 , \cf6 lis2\cf0 , \cf6 Res\cf0 ;\
\};\
\

\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b myClass :: padZeroes
\f0\b0 () \{\
    \ul Node<
\f1\b \cf3 \ulc3 int
\f0\b0 \cf0 \ulc0 >\ulnone * n1 = \cf6 lis1\cf0 .\ul head\ulnone ;\
    \ul Node<
\f1\b \cf3 \ulc3 int
\f0\b0 \cf0 \ulc0 >\ulnone * n2 = \cf6 lis2\cf0 .\ul head\ulnone ;\
    
\f1\b \cf3 if
\f0\b0 \cf0  (n1 == NULL && n2 == NULL) \{\
        cout << \cf4 "ERROR : Both input sum lists are empty!!"\cf0  << endl;\
	    
\f1\b \cf3 return
\f0\b0 \cf0 ;\
    \}\
    
\f1\b \cf3 while
\f0\b0 \cf0  ((n1->\ul next\ulnone  != NULL) || (n2->\ul next\ulnone  != NULL)) \{\
        
\f1\b \cf3 if
\f0\b0 \cf0  (n1->\ul next\ulnone  == NULL) \{ \
            \cf6 lis1\cf0 .\ul insertNode\ulnone (0); \cf2 //We have to pad at head/MSB\cf0 \
            n2 = n2->\ul next\ulnone ;\
        \} 
\f1\b \cf3 else
\f0\b0 \cf0  
\f1\b \cf3 if
\f0\b0 \cf0  (n2->\ul next\ulnone  == NULL) \{\
            \cf6 lis2\cf0 .\ul insertNode\ulnone (0); \cf2 //We have to pad at head/MSB\cf0 \
            n1 = n1->\ul next\ulnone ;\
        \} 
\f1\b \cf3 else
\f0\b0 \cf0  \{\
            n1 = n1->\ul next\ulnone ;\
            n2 = n2->\ul next\ulnone ;\
        \}\
    \}\
\
\}\
\

\f1\b \cf3 int
\f0\b0 \cf0  
\f1\b myClass :: doSumReverse
\f0\b0 (\ul Node<
\f1\b \cf3 \ulc3 int
\f0\b0 \cf0 \ulc0 >\ulnone * n1, \ul Node<
\f1\b \cf3 \ulc3 int
\f0\b0 \cf0 \ulc0 >\ulnone * n2) \{\
    
\f1\b \cf3 int
\f0\b0 \cf0  currVal = 0;\
    
\f1\b \cf3 int
\f0\b0 \cf0  carry = 0;\
    
\f1\b \cf3 int
\f0\b0 \cf0  carryNext = 0;\
    
\f1\b \cf3 int
\f0\b0 \cf0  nodeVal = 0;\
    \ul Node<
\f1\b \cf3 \ulc3 int
\f0\b0 \cf0 \ulc0 >\ulnone * ptr1;\
    \ul Node<
\f1\b \cf3 \ulc3 int
\f0\b0 \cf0 \ulc0 >\ulnone * ptr2;\
\
    
\f1\b \cf3 if
\f0\b0 \cf0  (n1==NULL && n2==NULL) \{ \cf2 //It will either be both NULL or no null as we are padding zeroes\cf0 \
	    
\f1\b \cf3 return
\f0\b0 \cf0  0;\
    \} \
    \
    
\f1\b \cf3 if
\f0\b0 \cf0  (n1->\ul next\ulnone  != NULL && n2->\ul next\ulnone  != NULL) \{\
        carry = \ul doSumReverse\ulnone (n1->\ul next\ulnone , n2->\ul next\ulnone );\
    \} \
    cout << \cf4 "Adding "\cf0  << n1->\ul data\ulnone  << \cf4 " to "\cf0  << n2->\ul data\ulnone  << \cf4 " and "\cf0  << carry << \ul endl\ulnone ;\
    currVal += n1->\ul data\ulnone ;\
    currVal += n2->\ul data\ulnone ;\
    currVal += carry;\
    nodeVal = currVal%10;\
    carryNext = (currVal >= 10) ? 1 : 0;\
    \cf6 Res\cf0 .\ul insertNode\ulnone (nodeVal); \cf2 //Insert at head\cf0 \
    cout << \cf4 "Node data is "\cf0  << nodeVal << endl;\
\
    
\f1\b \cf3 return
\f0\b0 \cf0  carryNext;\
\}\
\

\f1\b \cf3 int
\f0\b0 \cf0  
\f1\b main
\f0\b0 () \{\
    \
    \cf5 myClass\cf0  obj; \cf2 //Adding lists to class itself as we are \cf2 \ul \ulc2 gonna\cf2 \ulnone  modify them with pad\cf0 \
    obj.\cf6 lis2\cf0 .\ul insertNode\ulnone (6);\
    obj.\cf6 lis2\cf0 .\ul insertNode\ulnone (8);\
    obj.\cf6 lis2\cf0 .\ul insertNode\ulnone (7);\
    obj.\cf6 lis1\cf0 .\ul insertNode\ulnone (3); \
    obj.\cf6 lis1\cf0 .\ul insertNode\ulnone (9);  \
    obj.\cf6 lis1\cf0 .\ul insertNode\ulnone (5);\
    obj.\cf6 lis1\cf0 .\ul insertNode\ulnone (9); \
    cout << \cf4 "Original List1:"\cf0  << endl;\
    obj.\cf6 lis1\cf0 .\ul printLinkedList\ulnone ();\
    cout << \cf4 "Original List2:"\cf0  << endl;\
    obj.\cf6 lis2\cf0 .\ul printLinkedList\ulnone ();\
    \
    obj.padZeroes();\
\
    cout << \cf4 "Padded List1:"\cf0  << endl;\
    obj.\cf6 lis1\cf0 .\ul printLinkedList\ulnone ();\
    cout << \cf4 "Padded List2:"\cf0  << endl;\
    obj.\cf6 lis2\cf0 .\ul printLinkedList\ulnone ();\
    \
\pard\pardeftab720

\f1\b \cf0     \cf3 if\cf0  (obj.\ul doSumReverse\ulnone (obj.\cf6 lis1\cf0 .\ul head\ulnone , obj.\cf6 lis2\cf0 .\ul head\ulnone ) == 1) \cf2 //If there is a carry from MSB, add an extra digit\cf0 \
        obj.\cf6 Res\cf0 .\ul insertNode\ulnone (1);
\f0\b0  \
    cout << \cf4 "Sum List:"\cf0  << endl;\
    obj.\cf6 Res\cf0 .\ul printLinkedList\ulnone ();\
    
\f1\b \cf3 return
\f0\b0 \cf0  0;\
\}\
}