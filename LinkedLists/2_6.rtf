{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 Menlo-Bold;}
{\colortbl;\red255\green255\blue255;\red63\green127\blue95;\red127\green0\blue85;\red42\green0\blue255;
\red0\green80\blue50;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720

\f0\fs24 \cf2 //Algorithm  :  isPalindrome : Reverse the list and compare with original (only \cf2 \ul \ulc2 upto\cf2 \ulnone  half)\cf0 \
\cf2 //              Time Complexity : O(N); Space Complexity : O(N)\cf0 \
\cf2 //              isPalindromeIter : Fast Runner moves 2x as fast as slow runner. When fast\cf0 \
\cf2 //              runner reaches tail => slow runner is at mid. Push from mid to tail at stack.\cf0 \
\cf2 //              Time Complexity : O(N); Space Complexity : O(N)\cf0 \
\cf2 //              isPalindromeRecur : Length of \cf2 \ul \ulc2 linkedlist\cf2 \ulnone  is known.\cf0 \
\cf2 //              Recursive approach to return mid node and push to stack.\cf0 \
\cf2 //              Time Complexity : O(N); Space Complexity : O(N)\cf0 \
\
\pard\pardeftab720

\f1\b \cf3 using
\f0\b0 \cf0  
\f1\b \cf3 namespace
\f0\b0 \cf0  std;\

\f1\b \cf3 #include
\f0\b0 \cf0  \cf4 <iostream>\cf0 \

\f1\b \cf3 #include
\f0\b0 \cf0  \cf4 <stack>\cf0 \
\pard\pardeftab720

\f1\b \cf3 \ul \ulc3 #include
\f0\b0 \cf0 \ulc0  \cf4 \ulc4 "LinkedList.h"\cf0 \ulnone \
\
\pard\pardeftab720

\f1\b \cf3 class
\f0\b0 \cf0  \cf5 myClass\cf0  \{\
    
\f1\b \cf3 public
\f0\b0 \cf0  :\
            
\f1\b \cf3 bool
\f0\b0 \cf0  
\f1\b isPalindrome
\f0\b0 (\ul LinkedList<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone  lis);\
            
\f1\b \cf3 bool
\f0\b0 \cf0  
\f1\b isPalindromeIter
\f0\b0 (\ul LinkedList<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone  lis);\
            
\f1\b \cf3 bool
\f0\b0 \cf0  
\f1\b isPalindromeRecur
\f0\b0 (\ul LinkedList<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone  lis, 
\f1\b \cf3 int
\f0\b0 \cf0  length);\
            \ul Node<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone * 
\f1\b findMidNode
\f0\b0 (\ul LinkedList<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone  lis, 
\f1\b \cf3 int
\f0\b0 \cf0  length);\
            
\f1\b \cf3 int
\f0\b0 \cf0  
\f1\b findLength
\f0\b0 (\ul LinkedList<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone  lis);\
\};\
\

\f1\b \cf3 int
\f0\b0 \cf0  
\f1\b myClass :: findLength
\f0\b0 (\ul LinkedList<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone  lis) \{\
    \ul Node<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone * n = lis.\ul head\ulnone ;\
    
\f1\b \cf3 int
\f0\b0 \cf0  length = 0;\
    
\f1\b \cf3 while
\f0\b0 \cf0  (n->\ul next\ulnone  != NULL) \{\
        length++;\
        n = n->\ul next\ulnone ;\
    \}\
    length++; \cf2 //For head\cf0 \
    
\f1\b \cf3 return
\f0\b0 \cf0 (length);\
\}\
\

\f1\b \cf3 bool
\f0\b0 \cf0  
\f1\b myClass :: isPalindrome
\f0\b0 (\ul LinkedList<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone  lis) \{\
    \ul LinkedList<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone  RevLis;\
    \ul Node<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone * n = lis.\ul head\ulnone ;\
    \ul Node<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone * nLast;\
    \ul Node<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone * nRev;\
\
    
\f1\b \cf3 if
\f0\b0 \cf0  (lis.\ul head\ulnone  == NULL) \{\
        cout << \cf4 "ERROR: Empty list"\cf0  << endl;\
        
\f1\b \cf3 return
\f0\b0 \cf0  
\f1\b \cf3 false
\f0\b0 \cf0 ;\
    \}\
    \
    \cf2 //Process Head\cf0 \
    RevLis.\ul insertNode\ulnone (lis.\ul head\ulnone ->\ul data\ulnone ); \cf2 //Head==Tail for first element\cf0 \
    nLast = RevLis.\ul head\ulnone ;\
\
    \cf2 //Inserting at Head for RevLis so that last element is at head\cf0 \
    
\f1\b \cf3 while
\f0\b0 \cf0  (n->\ul next\ulnone  != NULL) \{\
        RevLis.\ul insertNode\ulnone (n->\ul next\ulnone ->\ul data\ulnone );\
        n = n->\ul next\ulnone ;\
    \}\
    RevLis.\ul printLinkedList\ulnone ();\
    \
    n = lis.\ul head\ulnone ;\
    nRev = RevLis.\ul head\ulnone ;\
    \cf2 //Compare \cf2 \ul \ulc2 lis\cf2 \ulnone  with RevLis\cf0 \
    
\f1\b \cf3 if
\f0\b0 \cf0  (n->\ul data\ulnone  != nRev->\ul data\ulnone ) \{\
        cout << \cf4 "Head = "\cf0  << n->\ul data\ulnone  << \cf4 " does not match tail "\cf0  << nRev->\ul data\ulnone  << \ul endl\ulnone ;\
        
\f1\b \cf3 return
\f0\b0 \cf0  
\f1\b \cf3 false
\f0\b0 \cf0 ;\
    \}\
\
    
\f1\b \cf3 while
\f0\b0 \cf0  (n->\ul next\ulnone  != NULL) \{ \cf2 //Both lists are same length\cf0 \
        
\f1\b \cf3 if
\f0\b0 \cf0  (n->\ul next\ulnone ->\ul data\ulnone  != nRev->\ul next\ulnone ->\ul data\ulnone ) \{\
            cout << \cf4 "Head = "\cf0  << n->\ul next\ulnone ->\ul data\ulnone  << \cf4 " does not match tail "\cf0  << nRev->\ul next\ulnone ->\ul data\ulnone  << \ul endl\ulnone ;\
            
\f1\b \cf3 return
\f0\b0 \cf0  
\f1\b \cf3 false
\f0\b0 \cf0 ;\
        \}\
        n = n->\ul next\ulnone ;\
        nRev = nRev->\ul next\ulnone ;\
    \}\
    
\f1\b \cf3 return
\f0\b0 \cf0  
\f1\b \cf3 true
\f0\b0 \cf0 ;\
\}\
\

\f1\b \cf3 bool
\f0\b0 \cf0  
\f1\b myClass :: isPalindromeIter
\f0\b0 (\ul LinkedList<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone  lis) \{\
    \ul Node<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone * fast = lis.\ul head\ulnone ;\
    \ul Node<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone * slow = lis.\ul head\ulnone ;\
    
\f1\b \cf3 bool
\f0\b0 \cf0  skip = 
\f1\b \cf3 true
\f0\b0 \cf0 ;\
    \ul stack<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone  stk;\
    \
    
\f1\b \cf3 if
\f0\b0 \cf0  (lis.\ul head\ulnone  == NULL) \{\
        cout << \cf4 "ERROR: Empty list"\cf0  << endl;\
        
\f1\b \cf3 return
\f0\b0 \cf0  
\f1\b \cf3 false
\f0\b0 \cf0 ;\
    \}  \
    \
    
\f1\b \cf3 while
\f0\b0 \cf0  (fast->\ul next\ulnone  != NULL) \{\
        
\f1\b \cf3 if
\f0\b0 \cf0  (!skip)  \
            slow = slow->\ul next\ulnone ;\
        skip = !skip;\
        fast = fast->\ul next\ulnone ;\
    \}\
    cout << \cf4 "Slow reached mid = "\cf0  << slow->\ul data\ulnone  << \ul endl\ulnone ;\
    \
    \cf2 //Push slow->next to tail in stack\cf0 \
    
\f1\b \cf3 while
\f0\b0 \cf0  (slow->\ul next\ulnone  != NULL) \{\
        cout << \cf4 "Pushing "\cf0  << slow->\ul next\ulnone ->\ul data\ulnone  << \cf4 " onto stack"\cf0  << \ul endl\ulnone ;\
        stk.\ul push\ulnone (slow->\ul next\ulnone ->\ul data\ulnone );\
        slow = slow->\ul next\ulnone ;\
    \}\
    \
    fast = lis.\ul head\ulnone ;\
    \
    
\f1\b \cf3 while
\f0\b0 \cf0  (!stk.\ul empty\ulnone ()) \{\
        
\f1\b \cf3 char
\f0\b0 \cf0  itr = stk.\ul top\ulnone ();\
        cout << \cf4 "Popping "\cf0  << itr << \cf4 " from stack"\cf0  << endl;\
        
\f1\b \cf3 if
\f0\b0 \cf0  (fast->\ul data\ulnone  != itr) \{\
            cout << \cf4 "Head = "\cf0  << fast->\ul data\ulnone  << \cf4 " does not match stack "\cf0  << itr << \ul endl\ulnone ;\
            
\f1\b \cf3 return
\f0\b0 \cf0  
\f1\b \cf3 false
\f0\b0 \cf0 ;\
        \}\
        stk.\ul pop\ulnone ();\
        fast = fast->\ul next\ulnone ;\
    \}\
    
\f1\b \cf3 return
\f0\b0 \cf0  
\f1\b \cf3 true
\f0\b0 \cf0 ;\
\}\
\
\pard\pardeftab720

\f1\b \cf3 \ul \ulc3 bool
\f0\b0 \cf0 \ulnone  
\f1\b myClass :: isPalindromeRecur
\f0\b0 (\ul LinkedList<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone  lis, 
\f1\b \cf3 int
\f0\b0 \cf0  length) \{\
    \ul LinkedList<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone  temp = lis;\
    \ul stack<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone  stk;\
    
\f1\b \cf3 if
\f0\b0 \cf0  (lis.\ul head\ulnone  == NULL) \{\
        cout << \cf4 "ERROR: Empty list"\cf0  << endl;\
        
\f1\b \cf3 return
\f0\b0 \cf0  
\f1\b \cf3 false
\f0\b0 \cf0 ;\
    \}\
    \
    \ul Node<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone * mid = findMidNode(temp, length);\
    
\f1\b \cf3 while
\f0\b0 \cf0  (mid->\ul next\ulnone  != NULL) \{\
        cout << \cf4 "Pushing "\cf0  << mid->\ul next\ulnone ->\ul data\ulnone  << \cf4 " onto stack"\cf0  << \ul endl\ulnone ;\
        stk.\ul push\ulnone (mid->\ul next\ulnone ->\ul data\ulnone );\
        mid = mid->\ul next\ulnone ;\
    \}\
    \
    \ul Node<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone * n = lis.\ul head\ulnone ;\
    
\f1\b \cf3 while
\f0\b0 \cf0  (!stk.\ul empty\ulnone ()) \{\
        
\f1\b \cf3 char
\f0\b0 \cf0  itr = stk.\ul top\ulnone ();\
        cout << \cf4 "Popping "\cf0  << itr << \cf4 " from stack"\cf0  << endl;\
        
\f1\b \cf3 if
\f0\b0 \cf0  (n->\ul data\ulnone  != itr) \{\
            cout << \cf4 "Head = "\cf0  << n->\ul data\ulnone  << \cf4 " does not match stack "\cf0  << itr << \ul endl\ulnone ;\
            
\f1\b \cf3 return
\f0\b0 \cf0  
\f1\b \cf3 false
\f0\b0 \cf0 ;\
        \}\
        stk.\ul pop\ulnone ();\
        n = n->\ul next\ulnone ;\
    \}\
\}\
\
\pard\pardeftab720
\cf0 \ul \ulc0 Node<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone * 
\f1\b myClass :: findMidNode
\f0\b0 (\ul LinkedList<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone  lis, 
\f1\b \cf3 int
\f0\b0 \cf0  length) \{\
    
\f1\b \cf3 if
\f0\b0 \cf0  ((length-2) == 0 || length == 1) \{\
        cout << \cf4 "Found mid node : "\cf0  << lis.\ul head\ulnone ->\ul data\ulnone  << \ul endl\ulnone ;\
        
\f1\b \cf3 return
\f0\b0 \cf0  lis.\ul head\ulnone ;\
    \}\
\
    lis.\ul head\ulnone  = lis.\ul head\ulnone ->\ul next\ulnone ;\
    \ul Node<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone * n = findMidNode(lis, length-2);\
    
\f1\b \cf3 return
\f0\b0 \cf0  n;\
\}\
\
\pard\pardeftab720

\f1\b \cf3 int
\f0\b0 \cf0  
\f1\b main
\f0\b0 () \{\
    \
    \ul LinkedList<
\f1\b \cf3 \ulc3 char
\f0\b0 \cf0 \ulc0 >\ulnone  lis; \cf2 //Odd length, even length\cf0 \
    \cf5 myClass\cf0  obj;\
    lis.\ul insertNode\ulnone (\cf4 'a'\cf0 );\
    lis.\ul insertNode\ulnone (\cf4 'b'\cf0 );\
    lis.\ul insertNode\ulnone (\cf4 'c'\cf0 );\
    lis.\ul insertNode\ulnone (\cf4 'f'\cf0 );  \
    lis.\ul insertNode\ulnone (\cf4 'b'\cf0 );\
    lis.\ul insertNode\ulnone (\cf4 'a'\cf0 ); \
    cout << \cf4 "Original List"\cf0  << endl;\
    lis.\ul printLinkedList\ulnone ();\
    \
    
\f1\b \cf3 if
\f0\b0 \cf0  (obj.isPalindromeRecur(lis, obj.findLength(lis))) \
        cout << \cf4 "List is a \cf4 \ul \ulc4 Palindrome\cf4 \ulnone "\cf0  << endl;\
    
\f1\b \cf3 else
\f0\b0 \cf0  \
        cout << \cf4 "List is NOT a \cf4 \ul \ulc4 Palindrome\cf4 \ulnone "\cf0  << endl;\
    
\f1\b \cf3 return
\f0\b0 \cf0  0;\
\}\
}