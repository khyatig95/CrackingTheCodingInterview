{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 Menlo-Bold;}
{\colortbl;\red255\green255\blue255;\red63\green127\blue95;\red127\green0\blue85;\red42\green0\blue255;
\red100\green70\blue50;\red0\green80\blue50;\red0\green0\blue192;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720

\f0\fs24 \cf2 //Algorithm :   Have each \cf2 \ul \ulc2 substack\cf2 \ulnone  store capacity/size and return if their capacity\cf0 \
\cf2 //              is exceeded\cf0 \
\
\pard\pardeftab720

\f1\b \cf3 using
\f0\b0 \cf0  
\f1\b \cf3 namespace
\f0\b0 \cf0  std;\

\f1\b \cf3 #include
\f0\b0 \cf0  \cf4 <iostream>\cf0 \
\pard\pardeftab720

\f1\b \cf3 \ul \ulc3 #include
\f0\b0 \cf0 \ulc0  \cf4 \ulc4 "Stack.h"\cf0 \ulnone \
\pard\pardeftab720

\f1\b \cf3 #include
\f0\b0 \cf0  \cf4 <vector>\cf0 \
\

\f1\b \cf3 template
\f0\b0 \cf0  <
\f1\b \cf3 typename
\f0\b0 \cf0  
\f1\b \cf5 T
\f0\b0 \cf0 > \

\f1\b \cf3 class
\f0\b0 \cf0  \cf6 subStack\cf0  \{\
    
\f1\b \cf3 private
\f0\b0 \cf0  :\
        
\f1\b \cf3 int
\f0\b0 \cf0  \cf7 capacity\cf0 , \cf7 size\cf0 ;\
        \ul Stack<
\f1\b \cf5 \ulc5 T
\f0\b0 \cf0 \ulc0 >\ulnone  \cf7 stk\cf0 ;\
    
\f1\b \cf3 public
\f0\b0 \cf0  :\
        
\f1\b subStack
\f0\b0 (
\f1\b \cf3 int
\f0\b0 \cf0  cap) \{\
            \cf7 capacity\cf0  = cap;\
            \cf7 size\cf0  = 0;\
        \}\
        
\f1\b \cf3 int
\f0\b0 \cf0  
\f1\b returnSize
\f0\b0 () \{\
            
\f1\b \cf3 return
\f0\b0 \cf0  \cf7 size\cf0 ;\
        \}\
        
\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b push
\f0\b0 (
\f1\b \cf5 T
\f0\b0 \cf0  val);\
        
\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b pop
\f0\b0 ();\
        
\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b print
\f0\b0 () \{\
            \cf7 stk\cf0 .\ul printStack\ulnone ();\
        \}\
        
\f1\b \cf3 bool
\f0\b0 \cf0  
\f1\b isEmpty
\f0\b0 () \{\
            
\f1\b \cf3 return
\f0\b0 \cf0  \cf7 stk\cf0 .\ul isEmpty\ulnone ();\
        \}\
        
\f1\b \cf3 bool
\f0\b0 \cf0  
\f1\b isFull
\f0\b0 () \{\
            
\f1\b \cf3 return
\f0\b0 \cf0 (\cf7 size\cf0 ==\cf7 capacity\cf0 );\
        \}\
        \ul Node<
\f1\b \cf5 \ulc5 T
\f0\b0 \cf0 \ulc0 >\ulnone * \cf7 tail\cf0  = \cf7 stk\cf0 .\ul peek\ulnone ();\
\}; \
\

\f1\b \cf3 template
\f0\b0 \cf0  <
\f1\b \cf3 typename
\f0\b0 \cf0  
\f1\b \cf5 T
\f0\b0 \cf0 > \

\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b subStack<T> :: push
\f0\b0 (
\f1\b \cf5 T
\f0\b0 \cf0  val) \{\
    
\f1\b \cf3 if
\f0\b0 \cf0  (\cf7 size\cf0  < \cf7 capacity\cf0 ) \{  \cf2 //There is space for new element\cf0 \
        \cf7 stk\cf0 .\ul push\ulnone (val);\
        \cf7 size\cf0 ++;\
        
\f1\b \cf3 return
\f0\b0 \cf0 ;\
    \}\
    cout << \cf4 "No space in subStack. Push unsuccessful"\cf0  << endl;\
\}\
\

\f1\b \cf3 template
\f0\b0 \cf0  <
\f1\b \cf3 typename
\f0\b0 \cf0  
\f1\b \cf5 T
\f0\b0 \cf0 > \

\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b subStack<T> :: pop
\f0\b0 () \{\
    \cf7 stk\cf0 .\ul pop\ulnone ();\
    
\f1\b \cf3 if
\f0\b0 \cf0  (\cf7 size\cf0  != 0) \
        \cf7 size\cf0 --;\
\}\
\pard\pardeftab720
\cf2 //////////////////////////////////////////\cf0 \
\cf2 /////////////////////////////////////////\cf0 \
\pard\pardeftab720

\f1\b \cf3 template
\f0\b0 \cf0  <
\f1\b \cf3 typename
\f0\b0 \cf0  
\f1\b \cf5 T
\f0\b0 \cf0 > \

\f1\b \cf3 class
\f0\b0 \cf0  \cf6 SetOfStacks\cf0  \{\
    
\f1\b \cf3 private
\f0\b0 \cf0  : \
        
\f1\b \cf3 int
\f0\b0 \cf0  \cf7 subCapacity\cf0 ;\
        
\f1\b \cf3 int
\f0\b0 \cf0  \cf7 currStackID\cf0 ;\
        \cf6 vector\cf0 <\cf6 subStack\cf0 <
\f1\b \cf5 T
\f0\b0 \cf0 >*> \cf7 vec\cf0 ;\
    
\f1\b \cf3 public
\f0\b0 \cf0  : \
        
\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b push
\f0\b0 (
\f1\b \cf5 T
\f0\b0 \cf0  val);\
        
\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b pop
\f0\b0 ();\
        
\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b print
\f0\b0 ();\
        
\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b popAtIndex
\f0\b0 (
\f1\b \cf3 int
\f0\b0 \cf0  stackID);\
        
\f1\b SetOfStacks
\f0\b0 (
\f1\b \cf3 int
\f0\b0 \cf0  cap) \{\
            \cf7 subCapacity\cf0  = cap;\
            \cf7 currStackID\cf0  = -1;\
        \}\
\};\
\

\f1\b \cf3 template
\f0\b0 \cf0  <
\f1\b \cf3 typename
\f0\b0 \cf0  
\f1\b \cf5 T
\f0\b0 \cf0 > \

\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b SetOfStacks<T> :: push
\f0\b0 (
\f1\b \cf5 T
\f0\b0 \cf0  val) \{\
    
\f1\b \cf3 if
\f0\b0 \cf0  (\cf7 vec\cf0 .empty()) \{\
        \cf7 currStackID\cf0 ++; \
        \cf6 subStack\cf0 <
\f1\b \cf5 T
\f0\b0 \cf0 >* s = 
\f1\b \cf3 new
\f0\b0 \cf0  \cf6 subStack\cf0 <
\f1\b \cf5 T
\f0\b0 \cf0 >(\cf7 subCapacity\cf0 );\
        \cf7 vec\cf0 .push_back(s);\
    \} 
\f1\b \cf3 else
\f0\b0 \cf0  
\f1\b \cf3 if
\f0\b0 \cf0  (\cf7 vec\cf0 [\cf7 currStackID\cf0 ]->isFull()) \{ \cf2 //Move to next sub-stack\cf0 \
        \cf7 currStackID\cf0 ++; \
        \cf6 subStack\cf0 <
\f1\b \cf5 T
\f0\b0 \cf0 >* s = 
\f1\b \cf3 new
\f0\b0 \cf0  \cf6 subStack\cf0 <
\f1\b \cf5 T
\f0\b0 \cf0 >(\cf7 subCapacity\cf0 );\
        \cf7 vec\cf0 .push_back(s);\
    \}\
    \cf7 vec\cf0 [\cf7 currStackID\cf0 ]->push(val);\
\
    cout << \cf4 "Pushed value "\cf0  << val << \cf4 " into stack id "\cf0  << \cf7 currStackID\cf0  << endl;\
\}\
\

\f1\b \cf3 template
\f0\b0 \cf0  <
\f1\b \cf3 typename
\f0\b0 \cf0  
\f1\b \cf5 T
\f0\b0 \cf0 > \

\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b SetOfStacks<T> :: pop
\f0\b0 () \{\
    
\f1\b \cf3 if
\f0\b0 \cf0  (\cf7 vec\cf0 .empty()) \{\
        cout << \cf4 "ERROR: Can NOT pop. Set of Stacks is Empty!!"\cf0  << endl;\
        
\f1\b \cf3 return
\f0\b0 \cf0 ;\
    \}\
    \cf7 vec\cf0 [\cf7 currStackID\cf0 ]->pop();\
    
\f1\b \cf3 if
\f0\b0 \cf0  (\cf7 vec\cf0 [\cf7 currStackID\cf0 ]->isEmpty()) \{\
        \cf7 vec\cf0 .erase(\cf7 vec\cf0 .end()-1); \cf2 //Delete last subStack object\cf0 \
        \cf7 currStackID\cf0 --;\
    \}\
    cout << \cf4 "Pop done and current stack ID = "\cf0  << \cf7 currStackID\cf0  << endl;\
\}\
\

\f1\b \cf3 template
\f0\b0 \cf0  <
\f1\b \cf3 typename
\f0\b0 \cf0  
\f1\b \cf5 T
\f0\b0 \cf0 > \

\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b SetOfStacks<T> :: print
\f0\b0 () \{\
    
\f1\b \cf3 int
\f0\b0 \cf0  count = 0;\
    
\f1\b \cf3 if
\f0\b0 \cf0  (\cf7 vec\cf0 .empty()) \{\
        cout << \cf4 "Set of Stacks is empty. Can NOT print"\cf0  << endl;\
        
\f1\b \cf3 return
\f0\b0 \cf0 ;\
    \}\
    
\f1\b \cf3 while
\f0\b0 \cf0 (count <= \cf7 currStackID\cf0 ) \{ \
        cout << \cf4 "Contents of sub stack "\cf0  << count << \cf4 " :"\cf0  << endl;\
        \cf7 vec\cf0 [count]->print();\
        count++;\
    \}\
\}\
\

\f1\b \cf3 template
\f0\b0 \cf0  <
\f1\b \cf3 typename
\f0\b0 \cf0  
\f1\b \cf5 T
\f0\b0 \cf0 >\

\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b SetOfStacks<T> :: popAtIndex
\f0\b0 (
\f1\b \cf3 int
\f0\b0 \cf0  stackID) \{\
    
\f1\b \cf3 if
\f0\b0 \cf0  (stackID > \cf7 currStackID\cf0 ) \{\
        cout << \cf4 "ERROR: Stack ID "\cf0  << stackID << \cf4 " does NOT exist"\cf0  << endl;\
        
\f1\b \cf3 return
\f0\b0 \cf0 ;\
    \}\
    cout << \cf4 "Pop from stack ID "\cf0  << stackID << endl;\
    \cf7 vec\cf0 [stackID]->pop();\
    
\f1\b \cf3 if
\f0\b0 \cf0  (\cf7 vec\cf0 [stackID]->isEmpty()) \
        \cf7 vec\cf0 .erase(\cf7 vec\cf0 .begin()+stackID);\
\}\
\
\

\f1\b \cf3 int
\f0\b0 \cf0  
\f1\b main
\f0\b0 () \{\
    \cf6 SetOfStacks\cf0 <
\f1\b \cf3 int
\f0\b0 \cf0 > ss(2);\
    ss.push(12);\
    ss.push(13);\
    ss.push(55);\
    ss.push(75);\
    ss.push(33);\
    ss.push(6);\
    \
    ss.print();\
    \
    ss.pop();\
    ss.popAtIndex(0);\
    \
    ss.print();\
\
    ss.pop();\
    ss.print();\
    ss.popAtIndex(2);\
    ss.pop();\
    ss.pop();\
    ss.pop();\
    \
    ss.print();\
    ss.pop(); \cf2 //Popping from empty stack\cf0 \
    
\f1\b \cf3 return
\f0\b0 \cf0  0;\
\}\
}