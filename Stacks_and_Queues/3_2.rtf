{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 Menlo-Bold;}
{\colortbl;\red255\green255\blue255;\red63\green127\blue95;\red127\green0\blue85;\red42\green0\blue255;
\red0\green80\blue50;\red0\green0\blue192;}
\margl1440\margr1440\vieww28300\viewh14680\viewkind0
\deftab720
\pard\pardeftab720

\f0\fs24 \cf2 //Assumption :  Stack contains \ul \ulc2 int\ulnone  elements only\cf0 \
\cf2 //Algorithm :   \ul Min\ulnone : Returns the \ul min\ulnone  element where at every push,\cf0 \
\cf2 //              you store the \ul min\ulnone  element so far so at pop, you \cf0 \
\cf2 //              still know the new \ul min\ulnone  element. (You can use a linkedlist to store val and min)\cf0 \
\cf2 //              Time Complexity : O(1); Space Complexity : O(N)\cf0 \
\
\pard\pardeftab720

\f1\b \cf3 using
\f0\b0 \cf0  
\f1\b \cf3 namespace
\f0\b0 \cf0  std;\

\f1\b \cf3 #include
\f0\b0 \cf0  \cf4 <iostream>\cf0 \
\pard\pardeftab720

\f1\b \cf3 \ul \ulc3 #include
\f0\b0 \cf0 \ulc0  \cf4 \ulc4 "Stack.h"\cf0 \ulnone \
\
\pard\pardeftab720

\f1\b \cf3 class
\f0\b0 \cf0  \cf5 minStack\cf0  \{\
    
\f1\b \cf3 public
\f0\b0 \cf0  : \
        
\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b push
\f0\b0 (
\f1\b \cf3 int
\f0\b0 \cf0  val);\
        
\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b pop
\f0\b0 ();\
        
\f1\b \cf3 int
\f0\b0 \cf0  
\f1\b Min
\f0\b0 ();\
        
\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b print
\f0\b0 ();\
    
\f1\b \cf3 private
\f0\b0 \cf0  : \
        \ul Stack<
\f1\b \cf3 \ulc3 int
\f0\b0 \cf0 \ulc0 >\ulnone  \cf6 stk\cf0 ;\
        \ul Stack<
\f1\b \cf3 \ulc3 int
\f0\b0 \cf0 \ulc0 >\ulnone  \cf6 minStk\cf0 ;\
\};\
\

\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b minStack :: push
\f0\b0 (
\f1\b \cf3 int
\f0\b0 \cf0  val) \{\
    
\f1\b \cf3 if
\f0\b0 \cf0  (\cf6 minStk\cf0 .\ul isEmpty\ulnone ()) \
        \cf6 minStk\cf0 .\ul push\ulnone (val);\
    
\f1\b \cf3 else
\f0\b0 \cf0  \{\
        
\f1\b \cf3 if
\f0\b0 \cf0  (\cf6 minStk\cf0 .\ul peek\ulnone ()->\ul data\ulnone  > val)  \cf2 //This is the new \ul \ulc2 min\cf0 \ulnone \
            \cf6 minStk\cf0 .\ul push\ulnone (val); \
        
\f1\b \cf3 else
\f0\b0 \cf0  \
            \cf6 minStk\cf0 .\ul push\ulnone (\cf6 minStk\cf0 .\ul peek\ulnone ()->\ul data\ulnone );\
    \} \
    \cf6 stk\cf0 .\ul push\ulnone (val);\
    cout << \cf4 "Pushed \ul \ulc4 val\ulnone  "\cf0  << val << \cf4 " and the current \ul min\ulnone  is "\cf0  << \cf6 minStk\cf0 .\ul peek\ulnone ()->\ul data\ulnone  << \ul endl\ulnone ; \
\}\
\

\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b minStack :: pop
\f0\b0 () \{\
    \cf6 minStk\cf0 .\ul pop\ulnone ();\
    \cf6 stk\cf0 .\ul pop\ulnone ();\
\}\
\

\f1\b \cf3 int
\f0\b0 \cf0  
\f1\b minStack :: Min
\f0\b0 () \{\
    
\f1\b \cf3 if
\f0\b0 \cf0  (\cf6 minStk\cf0 .\ul isEmpty\ulnone ()) \{\
        cout << \cf4 "ERROR: Stack is empty! Can't find \ul min\ulnone  element"\cf0  << endl;\
        
\f1\b \cf3 return
\f0\b0 \cf0  -1;\
    \} 
\f1\b \cf3 else
\f0\b0 \cf0 \
        
\f1\b \cf3 return
\f0\b0 \cf0 (\cf6 minStk\cf0 .\ul peek\ulnone ()->\ul data\ulnone );\
\}\
\

\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b minStack :: print
\f0\b0 () \{\
    \cf6 stk\cf0 .\ul printStack\ulnone ();\
\}\
\

\f1\b \cf3 int
\f0\b0 \cf0  
\f1\b main
\f0\b0 () \{\
    \cf5 minStack\cf0  obj;\
    obj.push(53);\
    cout << \cf4 "\ul Min\ulnone  in the stack is "\cf0  << obj.Min() << endl;\
    obj.push(45);\
    cout << \cf4 "\ul Min\ulnone  in the stack is "\cf0  << obj.Min() << endl;\
    obj.push(81);\
    cout << \cf4 "\ul Min\ulnone  in the stack is "\cf0  << obj.Min() << endl;\
    obj.push(32);\
    cout << \cf4 "\ul Min\ulnone  in the stack is "\cf0  << obj.Min() << endl;\
    obj.push(22);\
    cout << \cf4 "\ul Min\ulnone  in the stack is "\cf0  << obj.Min() << endl;\
    obj.print();\
    obj.pop();\
    cout << \cf4 "\ul Min\ulnone  in the stack is "\cf0  << obj.Min() << endl;\
    obj.pop();\
    cout << \cf4 "\ul Min\ulnone  in the stack is "\cf0  << obj.Min() << endl;\
    obj.print();\
    obj.pop();\
    cout << \cf4 "\ul Min\ulnone  in the stack is "\cf0  << obj.Min() << endl;\
    obj.pop();\
    cout << \cf4 "\ul Min\ulnone  in the stack is "\cf0  << obj.Min() << endl;\
    obj.pop();\
    cout << \cf4 "\ul Min\ulnone  in the stack is "\cf0  << obj.Min() << endl;\
\
    
\f1\b \cf3 return
\f0\b0 \cf0  0;\
\}\
}