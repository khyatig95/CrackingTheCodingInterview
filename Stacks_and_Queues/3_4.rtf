{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 Menlo-Bold;}
{\colortbl;\red255\green255\blue255;\red63\green127\blue95;\red127\green0\blue85;\red42\green0\blue255;
\red100\green70\blue50;\red0\green80\blue50;\red0\green0\blue192;}
\margl1440\margr1440\vieww28300\viewh14680\viewkind0
\deftab720
\pard\pardeftab720

\f0\fs24 \cf2 //Algorithm :   Keep pushing values at tail. When there is pop,\cf0 \
\cf2 //              reverse elements in another stack and then pop \cf0 \
\cf2 //              so the pops happen at head. \cf0 \
\cf2 //              \ul To prevent reversal at every operation, store \cf0 \ulc0 \
\cf2 \ulnone //              \ul which stack has elements is there are a series\cf0 \ulc0 \
\cf2 \ulnone //              \ul of push and pop.\cf0 \ulnone \
\cf2 //              Space Complexity : O(N)\cf0 \
\cf2 //              Push/Pop Time Complexity : O(N)\cf0 \
\
\pard\pardeftab720

\f1\b \cf3 using
\f0\b0 \cf0  
\f1\b \cf3 namespace
\f0\b0 \cf0  std;\

\f1\b \cf3 #include
\f0\b0 \cf0  \cf4 <iostream>\cf0 \
\pard\pardeftab720

\f1\b \cf3 \ul \ulc3 #include
\f0\b0 \cf0 \ulc0  \cf4 \ulc4 "Stack.h"\cf0 \ulnone \
\
\pard\pardeftab720

\f1\b \cf3 template
\f0\b0 \cf0  <
\f1\b \cf3 typename
\f0\b0 \cf0  
\f1\b \cf5 T
\f0\b0 \cf0 > \

\f1\b \cf3 class
\f0\b0 \cf0  \cf6 myQueue\cf0  \{\
    
\f1\b \cf3 private
\f0\b0 \cf0  :\
        \ul Stack<
\f1\b \cf5 \ulc5 T
\f0\b0 \cf0 \ulc0 >\ulnone  \cf7 pushQ\cf0 , \cf7 popQ\cf0 ;\
        
\f1\b \cf3 bool
\f0\b0 \cf0  \cf7 isPushQ\cf0  = 
\f1\b \cf3 true
\f0\b0 \cf0 ;\
        
\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b shiftQ
\f0\b0 ();\
    
\f1\b \cf3 public
\f0\b0 \cf0  :\
        
\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b push
\f0\b0 (
\f1\b \cf5 T
\f0\b0 \cf0  val);\
        
\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b pop
\f0\b0 ();\
        \ul Node<
\f1\b \cf5 \ulc5 T
\f0\b0 \cf0 \ulc0 >\ulnone * 
\f1\b peek
\f0\b0 ();  \cf2 //Looks at oldest element\cf0 \
        
\f1\b \cf3 bool
\f0\b0 \cf0  
\f1\b isEmpty
\f0\b0 ();\
        
\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b printQueue
\f0\b0 ();\
\};\
\

\f1\b \cf3 template
\f0\b0 \cf0  <
\f1\b \cf3 typename
\f0\b0 \cf0  
\f1\b \cf5 T
\f0\b0 \cf0 > \

\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b myQueue<T> :: push
\f0\b0 (
\f1\b \cf5 T
\f0\b0 \cf0  val) \{\
    
\f1\b \cf3 if
\f0\b0 \cf0  (!\cf7 isPushQ\cf0 )\
        shiftQ();\
    \cf7 pushQ\cf0 .\ul push\ulnone (val);\
\}\
\

\f1\b \cf3 template
\f0\b0 \cf0  <
\f1\b \cf3 typename
\f0\b0 \cf0  
\f1\b \cf5 T
\f0\b0 \cf0 > \

\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b myQueue<T> :: pop
\f0\b0 () \{\
    
\f1\b \cf3 if
\f0\b0 \cf0  (\cf7 isPushQ\cf0 )\
        shiftQ();\
    \cf7 popQ\cf0 .\ul pop\ulnone ();\
\}\
\

\f1\b \cf3 template
\f0\b0 \cf0  <
\f1\b \cf3 typename
\f0\b0 \cf0  
\f1\b \cf5 T
\f0\b0 \cf0 > \
\pard\pardeftab720
\cf0 \ul Node<
\f1\b \cf5 \ulc5 T
\f0\b0 \cf0 \ulc0 >\ulnone * 
\f1\b myQueue<T> :: peek
\f0\b0 () \{\
    
\f1\b \cf3 if
\f0\b0 \cf0  (\cf7 isPushQ\cf0 )\
        shiftQ();\
    
\f1\b \cf3 return
\f0\b0 \cf0 (\cf7 popQ\cf0 .\ul peek\ulnone ());\
\}\
\
\pard\pardeftab720

\f1\b \cf3 template
\f0\b0 \cf0  <
\f1\b \cf3 typename
\f0\b0 \cf0  
\f1\b \cf5 T
\f0\b0 \cf0 > \

\f1\b \cf3 bool
\f0\b0 \cf0  
\f1\b myQueue<T> :: isEmpty
\f0\b0 () \{\
    
\f1\b \cf3 if
\f0\b0 \cf0  (\cf7 isPushQ\cf0 )\
        
\f1\b \cf3 return
\f0\b0 \cf0 (\cf7 pushQ\cf0 .\ul isEmpty\ulnone ());\
    
\f1\b \cf3 else
\f0\b0 \cf0 \
        
\f1\b \cf3 return
\f0\b0 \cf0 (\cf7 popQ\cf0 .\ul isEmpty\ulnone ());\
\}\
\

\f1\b \cf3 template
\f0\b0 \cf0  <
\f1\b \cf3 typename
\f0\b0 \cf0  
\f1\b \cf5 T
\f0\b0 \cf0 >\

\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b myQueue<T> :: shiftQ
\f0\b0 () \{\
    
\f1\b \cf3 if
\f0\b0 \cf0  (\cf7 isPushQ\cf0 ) \{\
        cout << \cf4 "Current q = PushQ and shifting to PopQ"\cf0  << endl;\
        
\f1\b \cf3 while
\f0\b0 \cf0  (!\cf7 pushQ\cf0 .\ul isEmpty\ulnone ()) \{\
            \cf7 popQ\cf0 .\ul push\ulnone (\cf7 pushQ\cf0 .\ul peek\ulnone ()->\ul data\ulnone );\
            \cf7 pushQ\cf0 .\ul pop\ulnone ();\
        \}\
    \} 
\f1\b \cf3 else
\f0\b0 \cf0  \{\
        cout << \cf4 "Current q = PopQ and shifting to PushQ"\cf0  << endl;\
        
\f1\b \cf3 while
\f0\b0 \cf0  (!\cf7 popQ\cf0 .\ul isEmpty\ulnone ()) \{\
            \cf7 pushQ\cf0 .\ul push\ulnone (\cf7 popQ\cf0 .\ul peek\ulnone ()->\ul data\ulnone );\
            \cf7 popQ\cf0 .\ul pop\ulnone ();\
        \}\
    \}\
    \cf7 isPushQ\cf0  = !\cf7 isPushQ\cf0 ;\
\}\
\

\f1\b \cf3 template
\f0\b0 \cf0  <
\f1\b \cf3 typename
\f0\b0 \cf0  
\f1\b \cf5 T
\f0\b0 \cf0 >\

\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b myQueue<T> :: printQueue
\f0\b0 () \{\
    cout << \cf4 "PushQ is :"\cf0  << endl;\
    \cf7 pushQ\cf0 .\ul printStack\ulnone ();\
    cout << endl << \cf4 "PopQ is :"\cf0  << endl;\
    \cf7 popQ\cf0 .\ul printStack\ulnone ();\
\} \
\

\f1\b \cf3 int
\f0\b0 \cf0  
\f1\b main
\f0\b0 () \{\
    \cf6 myQueue\cf0 <
\f1\b \cf3 int
\f0\b0 \cf0 > que;\
    que.push(23);\
    que.push(45);\
    que.push(70);\
    que.push(81);\
    que.push(92);\
    que.printQueue();\
    que.pop();\
    que.pop();\
    que.printQueue();\
    cout << \cf4 "Top of the stack is "\cf0  << que.peek()->\ul data\ulnone  << \ul endl\ulnone ;\
    
\f1\b \cf3 if
\f0\b0 \cf0  (que.isEmpty())\
        cout << \cf4 "Queue is Empty"\cf0  << endl;\
    
\f1\b \cf3 else
\f0\b0 \cf0  \
        cout << \cf4 "Queue is NOT Empty"\cf0  << endl;\
    que.pop();\
    que.pop();\
    que.pop();\
    
\f1\b \cf3 if
\f0\b0 \cf0  (que.isEmpty())\
        cout << \cf4 "Queue is Empty"\cf0  << endl;\
    
\f1\b \cf3 else
\f0\b0 \cf0  \
        cout << \cf4 "Queue is NOT Empty"\cf0  << endl;\
    que.pop(); \cf2 //Pop on empty queue\cf0 \
    \
    que.push(3);\
    que.push(55);\
    que.printQueue();\
    que.pop();\
    que.printQueue();\
    \
    
\f1\b \cf3 return
\f0\b0 \cf0  0;\
\
\}\
3_}