{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 Menlo-Bold;}
{\colortbl;\red255\green255\blue255;\red63\green127\blue95;\red127\green0\blue85;\red42\green0\blue255;
\red0\green80\blue50;\red0\green0\blue192;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720

\f0\fs24 \cf2 //Algorithm :   Assume the \cf2 \ul \ulc2 temp\cf2 \ulnone  stack is sorted such that largest element is on\cf0 \
\cf2 //              top. Store unsorted stack top element in \cf2 \ul \ulc2 temp\cf2 \ulnone  variable. \cf0 \
\cf2 //              Pop \cf2 \ul \ulc2 temp\cf2 \ulnone  elements into the unsorted stack  till you find the \cf2 \ul \ulc2 temp\cf0 \ulnone \
\cf2 //              variable greater than the top of sorted stack\cf0 \
\cf2 //              Time Complexity : O(N^2); Space Complexity : O(N)\cf0 \
\
\pard\pardeftab720

\f1\b \cf3 using
\f0\b0 \cf0  
\f1\b \cf3 namespace
\f0\b0 \cf0  std;\

\f1\b \cf3 #include
\f0\b0 \cf0  \cf4 <iostream>\cf0 \
\pard\pardeftab720

\f1\b \cf3 \ul \ulc3 #include
\f0\b0 \cf0 \ulc0  \cf4 \ulc4 "Stack.h"\cf0 \ulnone \
\
\pard\pardeftab720

\f1\b \cf3 class
\f0\b0 \cf0  \cf5 SortedStack\cf0  \{\
    
\f1\b \cf3 private
\f0\b0 \cf0  :\
        \ul Stack<
\f1\b \cf3 \ulc3 int
\f0\b0 \cf0 \ulc0 >\ulnone  \cf6 temp\cf0 ;\
        
\f1\b \cf3 int
\f0\b0 \cf0  \cf6 tempdata\cf0 ;\
    
\f1\b \cf3 public
\f0\b0 \cf0  :\
        \ul Stack<
\f1\b \cf3 \ulc3 int
\f0\b0 \cf0 \ulc0 >\ulnone  \cf6 stk\cf0 ;\
        
\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b sort
\f0\b0 ();\
        
\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b print
\f0\b0 () \{\
            \cf6 stk\cf0 .\ul printStack\ulnone ();\
        \}\
\};\
\

\f1\b \cf3 void
\f0\b0 \cf0  
\f1\b SortedStack :: sort
\f0\b0 () \{\
    
\f1\b \cf3 if
\f0\b0 \cf0  (\cf6 stk\cf0 .\ul isEmpty\ulnone ()) \{\
        cout << \cf4 "ERROR: Stack is empty! Can't Sort"\cf0  << endl;\
        
\f1\b \cf3 return
\f0\b0 \cf0 ;\
    \}\
    
\f1\b \cf3 if
\f0\b0 \cf0  (\cf6 temp\cf0 .\ul isEmpty\ulnone ()) \{\
        \cf6 temp\cf0 .\ul push\ulnone (\cf6 stk\cf0 .\ul peek\ulnone ()->\ul data\ulnone );\
        \cf6 stk\cf0 .\ul pop\ulnone ();\
    \}\
    
\f1\b \cf3 while
\f0\b0 \cf0  (!\cf6 stk\cf0 .\ul isEmpty\ulnone ()) \{\
        \cf6 tempdata\cf0  = \cf6 stk\cf0 .\ul peek\ulnone ()->\ul data\ulnone ;\
        \cf6 stk\cf0 .\ul pop\ulnone (); \cf2 //Pop the element from stack\cf0 \
        
\f1\b \cf3 while
\f0\b0 \cf0 (\cf6 temp\cf0 .\ul peek\ulnone ()->\ul data\ulnone  > \cf6 tempdata\cf0 ) \{\
            \cf6 stk\cf0 .\ul push\ulnone (\cf6 temp\cf0 .\ul peek\ulnone ()->\ul data\ulnone ); \cf2 //Push the elements greater than \cf2 \ul \ulc2 tempdata\cf2 \ulnone  into OG stack.\cf0 \
            \cf6 temp\cf0 .\ul pop\ulnone ();\
            
\f1\b \cf3 if
\f0\b0 \cf0  (\cf6 temp\cf0 .\ul isEmpty\ulnone ())\
                
\f1\b \cf3 break
\f0\b0 \cf0 ;\
        \}\
        \cf6 temp\cf0 .\ul push\ulnone (\cf6 tempdata\cf0 ); \cf2 //Store the \cf2 \ul \ulc2 tempdata\cf2 \ulnone  into \cf2 \ul \ulc2 temp\cf2 \ulnone  \cf0 \
    \}\
    
\f1\b \cf3 while
\f0\b0 \cf0 (!\cf6 temp\cf0 .\ul isEmpty\ulnone ()) \{\
        \cf6 stk\cf0 .\ul push\ulnone (\cf6 temp\cf0 .\ul peek\ulnone ()->\ul data\ulnone );\
        \cf6 temp\cf0 .\ul pop\ulnone ();\
    \}\
\}\
\

\f1\b \cf3 int
\f0\b0 \cf0  
\f1\b main
\f0\b0 () \{\
    \cf5 SortedStack\cf0  ss;\
    ss.\cf6 stk\cf0 .\ul push\ulnone (1);\
    ss.\cf6 stk\cf0 .\ul push\ulnone (33);\
    ss.\cf6 stk\cf0 .\ul push\ulnone (45);\
    ss.\cf6 stk\cf0 .\ul push\ulnone (67);\
    ss.\cf6 stk\cf0 .\ul push\ulnone (100);\
    ss.print();\
    \
    cout << \cf4 "Sorting .."\cf0  << endl;\
    ss.sort();\
    cout << \cf4 "Sorted stack "\cf0  << endl;\
    ss.print();\
\
\}\
}